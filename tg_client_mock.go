// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package main

import (
	"context"
	"github.com/gotd/td/telegram/auth"
	"github.com/gotd/td/tg"
	"sync"
)

// Ensure, that tgClientInterfaceMock does implement tgClientInterface.
// If this is not the case, regenerate this file with moq.
var _ tgClientInterface = &tgClientInterfaceMock{}

// tgClientInterfaceMock is a mock implementation of tgClientInterface.
//
//	func TestSomethingThatUsestgClientInterface(t *testing.T) {
//
//		// make and configure a mocked tgClientInterface
//		mockedtgClientInterface := &tgClientInterfaceMock{
//			APIFunc: func() *tg.Client {
//				panic("mock out the API method")
//			},
//			AuthFunc: func() *auth.Client {
//				panic("mock out the Auth method")
//			},
//			RunFunc: func(ctx context.Context, f func(ctx context.Context) error) error {
//				panic("mock out the Run method")
//			},
//		}
//
//		// use mockedtgClientInterface in code that requires tgClientInterface
//		// and then make assertions.
//
//	}
type tgClientInterfaceMock struct {
	// APIFunc mocks the API method.
	APIFunc func() *tg.Client

	// AuthFunc mocks the Auth method.
	AuthFunc func() *auth.Client

	// RunFunc mocks the Run method.
	RunFunc func(ctx context.Context, f func(ctx context.Context) error) error

	// calls tracks calls to the methods.
	calls struct {
		// API holds details about calls to the API method.
		API []struct {
		}
		// Auth holds details about calls to the Auth method.
		Auth []struct {
		}
		// Run holds details about calls to the Run method.
		Run []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// F is the f argument value.
			F func(ctx context.Context) error
		}
	}
	lockAPI  sync.RWMutex
	lockAuth sync.RWMutex
	lockRun  sync.RWMutex
}

// API calls APIFunc.
func (mock *tgClientInterfaceMock) API() *tg.Client {
	if mock.APIFunc == nil {
		panic("tgClientInterfaceMock.APIFunc: method is nil but tgClientInterface.API was just called")
	}
	callInfo := struct {
	}{}
	mock.lockAPI.Lock()
	mock.calls.API = append(mock.calls.API, callInfo)
	mock.lockAPI.Unlock()
	return mock.APIFunc()
}

// APICalls gets all the calls that were made to API.
// Check the length with:
//
//	len(mockedtgClientInterface.APICalls())
func (mock *tgClientInterfaceMock) APICalls() []struct {
} {
	var calls []struct {
	}
	mock.lockAPI.RLock()
	calls = mock.calls.API
	mock.lockAPI.RUnlock()
	return calls
}

// Auth calls AuthFunc.
func (mock *tgClientInterfaceMock) Auth() *auth.Client {
	if mock.AuthFunc == nil {
		panic("tgClientInterfaceMock.AuthFunc: method is nil but tgClientInterface.Auth was just called")
	}
	callInfo := struct {
	}{}
	mock.lockAuth.Lock()
	mock.calls.Auth = append(mock.calls.Auth, callInfo)
	mock.lockAuth.Unlock()
	return mock.AuthFunc()
}

// AuthCalls gets all the calls that were made to Auth.
// Check the length with:
//
//	len(mockedtgClientInterface.AuthCalls())
func (mock *tgClientInterfaceMock) AuthCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockAuth.RLock()
	calls = mock.calls.Auth
	mock.lockAuth.RUnlock()
	return calls
}

// Run calls RunFunc.
func (mock *tgClientInterfaceMock) Run(ctx context.Context, f func(ctx context.Context) error) error {
	if mock.RunFunc == nil {
		panic("tgClientInterfaceMock.RunFunc: method is nil but tgClientInterface.Run was just called")
	}
	callInfo := struct {
		Ctx context.Context
		F   func(ctx context.Context) error
	}{
		Ctx: ctx,
		F:   f,
	}
	mock.lockRun.Lock()
	mock.calls.Run = append(mock.calls.Run, callInfo)
	mock.lockRun.Unlock()
	return mock.RunFunc(ctx, f)
}

// RunCalls gets all the calls that were made to Run.
// Check the length with:
//
//	len(mockedtgClientInterface.RunCalls())
func (mock *tgClientInterfaceMock) RunCalls() []struct {
	Ctx context.Context
	F   func(ctx context.Context) error
} {
	var calls []struct {
		Ctx context.Context
		F   func(ctx context.Context) error
	}
	mock.lockRun.RLock()
	calls = mock.calls.Run
	mock.lockRun.RUnlock()
	return calls
}
